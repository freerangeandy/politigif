{
  "name": "jsgif",
  "version": "1.0.0-alpha.2",
  "description": "Pure JavaScript GIF encoder.",
  "main": "dist/commonjs/GifEncoder.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/AlicanC/jsgif.git"
  },
  "author": {
    "name": "Alican Çubukçuoğlu",
    "email": "alicancubukcuoglu@gmail.com",
    "url": "https://github.com/AlicanC"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/AlicanC/jsgif/issues"
  },
  "homepage": "https://github.com/AlicanC/jsgif#readme",
  "devDependencies": {
    "babel-core": "^6.3.15",
    "babel-loader": "^6.2.0",
    "babel-plugin-transform-runtime": "^6.3.13",
    "babel-preset-es2015": "^6.3.13",
    "babel-preset-stage-3": "^6.3.13",
    "babelify": "^7.2.0",
    "browserify": "^12.0.1",
    "fs-extra": "^0.26.2",
    "gulp": "github:gulpjs/gulp#4.0",
    "gulp-babel": "^6.1.1",
    "gulp-sourcemaps": "^1.6.0",
    "gulp-uglify": "^1.5.1",
    "gulp-util": "^3.0.7",
    "vinyl-buffer": "^1.0.0",
    "vinyl-source-stream": "^1.1.0"
  },
  "dependencies": {
    "babel-polyfill": "^6.3.14"
  },
  "gitHead": "b618e6ad32c1f79688cb01aae30fa0b067a45c56",
  "readme": "Pure JavaScript HTML5 <canvas> to (Animated) GIF Conversion\n===========================================================\n\nBased on [as3gif](http://code.google.com/p/as3gif/) Ported by [Kevin Kwok](http://antimatter15.com)\n\n![This is the raw canvas element saved as a non-animated PNG](Demos/raw_canvas.png)\n![This is the GIF which was generated from the canvas.](Demos/converted_animation.gif)\n![This is the GIF which was generated from the canvas.](Demos/clock.gif)\n\n> AS3GIF lets you play and encode animated GIF's with ActionScript 3\n\nSince web pages can usually natively play GIFs fine, it's only a port of the GIFEncoder\nportions of the library.\n\n\nBasic Usage\n============\n\nSince it pretty much *is* GIFEncoder, you could consult the [as3gif how-to page](http://code.google.com/p/as3gif/wiki/How_to_use#The_GIFEncoder)\n\n\nBut there are some differences so I'll cover it here anyway.\n\nYou first need to include the JS files. It's probably best if you include it in this order, but it shouldn't matter too much.\n\n    <script type=\"text/javascript\" src=\"LZWEncoder.js\"></script>\n    <script type=\"text/javascript\" src=\"NeuQuant.js\"></script>\n    <script type=\"text/javascript\" src=\"GIFEncoder.js\"></script>\n\nIf you want to render the gif through an inline `<img>` tag or try to save to disk or send to server or anything that requires\nconversion into a non-binary string form, you should probably include `b64.js` too.\n\n    <script type=\"text/javascript\" src=\"b64.js\"></script>\n\nSimple enough right? Now to convert stuff to GIF, you need to have a working <canvas> or at least some imageData-esque array.\n\n    <canvas id=\"bitmap\"></canvas>\n    <script>\n      var canvas = document.getElementById('bitmap');\n      var context = canvas.getContext('2d');\n      context.fillStyle = 'rgb(255,255,255)';\n      context.fillRect(0,0,canvas.width, canvas.height); //GIF can't do transparent so do white\n      \n      context.fillStyle = \"rgb(200,0,0)\";  \n      context.fillRect (10, 10, 75, 50);   //draw a little red box\n      \nNow we need to init the GIFEncoder.\n\n      var encoder = new GIFEncoder();\n\n*If* you are making an animated gif, you need to add the following\n\n      encoder.setRepeat(0); //0  -> loop forever\n                            //1+ -> loop n times then stop\n      encoder.setDelay(500); //go to next frame every n milliseconds\n      \nNow, you need to tell the magical thing that you're gonna start inserting frames (even if it's only one).\n      \n      encoder.start();\n      \nAnd for the part that took the longest to port: adding a real frame.\n\n      encoder.addFrame(context);\n      \nIn the GIFEncoder version, it accepts a Bitmap. Well, that doesn't exist in Javascript (natively, anyway)\nso instead, I use what I feel is a decent analogue: the canvas context. However, if you're in a situation\nwhere you don't have a real `<canvas>` element. That's _okay_. You can set the second parameter to true and\npass a imageData.data-esque array as your first argument. So in other words, you can do `encoder.addFrame(fake_imageData, true)`\nas an alternative. However, you _must_ do an `encoder.setSize(width, height);` before you do any of the addFrames if you\npass a imageData.data-like array. If you pass a canvas context, then that's all okay, because it will automagically do a \nsetSize with the canvas width/height stuff.\n\nNow the last part is to finalize the animation and get it for display.\n\n      encoder.finish();\n      var binary_gif = encoder.stream().getData() //notice this is different from the as3gif package!\n      var data_url = 'data:image/gif;base64,'+encode64(binary_gif);\n      \nDocs\n====\n\nEach of the files exposes a single global (see, at least it's considerate!). But since there's three files, that means that \nthere's three globals. But two of them are more of supporting libraries that I don't totally understand or care about enough\nto document. So I'm just gonna document GIFEncoder.\n\n`new GIFEncoder()` This is super parent function. You really don't need the `new` keyword because It's not really even using\nany special inheritance pattern. It's a closure that does some `var blah = exports.blah = function blah(){` for no good reason.\nAnyway, it returns an object with a bunch of methods that the section will be devoted to documenting. Note that I've never tested\nmore than half of these, so good luck.\n\n\n`Boolean start()` This writes the GIF Header and returns `false` if it fails.\n\n`Boolean addFrame(CanvasRenderingContext2D context)` This is the magical magic behind everything. This adds a frame.\n\n`Boolean addFrame(CanvasPixelArray image, true)` This is the magical magic behind everything. This adds a frame. This time you need \nyou pass `true` as the second argument and then magic strikes and it loads your canvas pixel array (which can be a real array, I dont\ncare and I think the program has learned from my constant apathy to also not care). But note that if you do, you must first manually call\n`setSize` which is happily defined just below this one.\n\n`void setSize(width, height)` Sets the canvas size. It's supposed to be private, but I'm exposing it anyway. Gets called automagically\nas the size of the first frame if you don't do that crappy hacky imageData.data hack.\n\n`void setDelay(int milliseconds)` the number of milliseconds to wait on each frame\n\n`void setDispose(int code)` Sets the GIF frame disposal code for the last added frame and any\nsubsequent frames. Default is 0 if no transparent color has been set, otherwise 2. I have no clue what this means so I just copypasted\nit from the actionscript docs.\n\n`void setFrameRate(Number fps)` Sets frame rate in frames per second. Equivalent to `setDelay(1000/fps)`. I think that's stupid.\n\n`void setQuality(int quality)` Sets quality of color quantization (conversion of images to the maximum 256 colors allowed by the \nGIF specification). Lower values (minimum = 1) produce better colors, but slow processing significantly. 10 is the default, and produces \ngood color mapping at reasonable speeds. Values greater than 20 do not yield significant improvements in speed. BLAH BLAH BLAH. Whatever\n\n`void setRepeat(int iter)` Sets the number of times the set of GIF frames should be played. Default is 1; 0 means play indefinitely. \nMust be invoked before the first image is added.\n\n`void setTransparent(Number color)` Sets the transparent color for the last added frame and any subsequent\nframes. Since all colors are subject to modification in the quantization\nprocess, the color in the final palette for each frame closest to the given\ncolor becomes the transparent color for that frame. May be set to null to\nindicate no transparent color.\n\n`ByteArray finish()` Adds final trailer to the GIF stream, if you don't call the finish method the GIF stream will not be valid. \n\n`String stream()` Yay the only function that returns a non void/boolean. It's the magical stream function which should have been a getter which JS does\nsupport but I didnt' feel like making it a getter because getters are so weird and inconsistent. Like sure there's the nice pretty `get` thing\nbut I think IE9/8 doesn't implement it because it's non standard or something and replaced it with a hideously ugly blah blah. So Anyway, it's a function.\nIt returns a byteArray with three writeByte functions that you wouldn't care about and a `getData()` function which returns a binary string with the GIF.\nThere's also a `.bin` attribute which contains an array with the binary stuff that I don't care about.\n\n      \nWebWorkers\n============\n\nThe process isn't really the fastest thing ever, so you should\nuse WebWorkers for piecing together animations more than a few frames\nlong.\n\n\nI haven't actually tried it yet, but here's some incomplete mock-JS which\nshould be able to do stuff once you add the boring stuff like serializing\nand deserializing the content (actually, i have most of the serializing done\nbut you have to deserialize that and that's really the boring part).\n\n    var frame_index,\n        frame_length,\n        height, \n        width,\n        imageData; //get it from onmessage\n        \n    var encoder = new GIFEncoder(); //create a new GIFEncoder for every new job\n    if(frame_index == 0){\n      encoder.start();\n    }else{\n      encoder.setProperties(true, true); //started, firstFrame\n    }\n    encoder.setSize(height, width);\n    encoder.addFrame(imageData, true);\n    if(frame_length == frame_index){\n      encoder.finish()\n    }\n    postMessage(frame_index + encoder.stream().getData()) //on the page, search for the GIF89a to see the frame_index\n\n\n    var animation_parts = new Array(frame_length);\n    //on the handler side:\n\n    var worker = new WebWorker('blahblahblah.js');\n    worker.onmessage = function(e){\n      //handle stuff, like get the frame_index\n      animation_parts[frame_index] = frame_data;\n      //check when everything else is done and then do animation_parts.join('') and have fun\n    }\n    var imdata = context.getImageData(0,0,canvas.width,canvas.height)\n    var len = canvas.width * canvas.height * 4;\n    var imarray = [];\n    for(var i = 0; i < len; i++){\n      imarray.push(imdata[i]);\n    }\n\n    worker.postMessage(frame_index + ';' + frame_length + ';' + canvas.height + ';' + canvas.width + ';' + imarray.join(','))\n",
  "readmeFilename": "README.md",
  "_id": "jsgif@1.0.0-alpha.2",
  "_shasum": "711aa2c5c45009750c85d83dcf85ecdc40381bfe",
  "_from": "git://github.com/AlicanC/jsgif.git#1.0.0-alpha.2",
  "_resolved": "git://github.com/AlicanC/jsgif.git#b618e6ad32c1f79688cb01aae30fa0b067a45c56"
}
