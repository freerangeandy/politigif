{"version":3,"sources":["LZWEncoder.js"],"names":[],"mappings":"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","file":"LZWEncoder.js","sourcesContent":["/**\r\n * This class handles LZW encoding\r\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\r\n\r\nexport default class LZWEncoder {\r\n\tconstructor() {\r\n\t\tvar exports = {};\r\n\t\tvar EOF = -1;\r\n\t\tvar imgW;\r\n\t\tvar imgH;\r\n\t\tvar pixAry;\r\n\t\tvar initCodeSize;\r\n\t\tvar remaining;\r\n\t\tvar curPixel;\r\n\r\n\t\t// GIFCOMPR.C - GIF Image compression routines\r\n\t\t// Lempel-Ziv compression based on 'compress'. GIF modifications by\r\n\t\t// David Rowley (mgardi@watdcsu.waterloo.edu)\r\n\t\t// General DEFINEs\r\n\r\n\t\tvar BITS = 12;\r\n\t\tvar HSIZE = 5003; // 80% occupancy\r\n\r\n\t\t// GIF Image compression - modified 'compress'\r\n\t\t// Based on: compress.c - File compression ala IEEE Computer, June 1984.\r\n\t\t// By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\r\n\t\t// Jim McKie (decvax!mcvax!jim)\r\n\t\t// Steve Davies (decvax!vax135!petsd!peora!srd)\r\n\t\t// Ken Turkowski (decvax!decwrl!turtlevax!ken)\r\n\t\t// James A. Woods (decvax!ihnp4!ames!jaw)\r\n\t\t// Joe Orost (decvax!vax135!petsd!joe)\r\n\r\n\t\tvar n_bits; // number of bits/code\r\n\t\tvar maxbits = BITS; // user settable max # bits/code\r\n\t\tvar maxcode; // maximum code, given n_bits\r\n\t\tvar maxmaxcode = 1 << BITS; // should NEVER generate this code\r\n\t\tvar htab = [];\r\n\t\tvar codetab = [];\r\n\t\tvar hsize = HSIZE; // for dynamic table sizing\r\n\t\tvar free_ent = 0; // first unused entry\r\n\r\n\t\t// block compression parameters -- after all codes are used up,\r\n\t\t// and compression rate changes, start over.\r\n\r\n\t\tvar clear_flg = false;\r\n\r\n\t\t// Algorithm: use open addressing double hashing (no chaining) on the\r\n\t\t// prefix code / next character combination. We do a variant of Knuth's\r\n\t\t// algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\r\n\t\t// secondary probe. Here, the modular division first probe is gives way\r\n\t\t// to a faster exclusive-or manipulation. Also do block compression with\r\n\t\t// an adaptive reset, whereby the code table is cleared when the compression\r\n\t\t// ratio decreases, but after the table fills. The variable-length output\r\n\t\t// codes are re-sized at this point, and a special CLEAR code is generated\r\n\t\t// for the decompressor. Late addition: construct the table according to\r\n\t\t// file size for noticeable speed improvement on small files. Please direct\r\n\t\t// questions about this implementation to ames!jaw.\r\n\r\n\t\tvar g_init_bits;\r\n\t\tvar ClearCode;\r\n\t\tvar EOFCode;\r\n\r\n\t\t// output\r\n\t\t// Output the given code.\r\n\t\t// Inputs:\r\n\t\t// code: A n_bits-bit integer. If == -1, then EOF. This assumes\r\n\t\t// that n_bits =< wordsize - 1.\r\n\t\t// Outputs:\r\n\t\t// Outputs code to the file.\r\n\t\t// Assumptions:\r\n\t\t// Chars are 8 bits long.\r\n\t\t// Algorithm:\r\n\t\t// Maintain a BITS character long buffer (so that 8 codes will\r\n\t\t// fit in it exactly). Use the VAX insv instruction to insert each\r\n\t\t// code in turn. When the buffer fills up empty it and start over.\r\n\r\n\t\tvar cur_accum = 0;\r\n\t\tvar cur_bits = 0;\r\n\t\tvar masks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\r\n\r\n\t\t// Number of characters so far in this 'packet'\r\n\t\tvar a_count;\r\n\r\n\t\t// Define the storage for the packet accumulator\r\n\t\tvar accum = [];\r\n\r\n\t\tvar LZWEncoder = exports.LZWEncoder = function LZWEncoder(width, height, pixels, color_depth) {\r\n\t\t\timgW = width;\r\n\t\t\timgH = height;\r\n\t\t\tpixAry = pixels;\r\n\t\t\tinitCodeSize = Math.max(2, color_depth);\r\n\t\t};\r\n\r\n\t\t// Add a character to the end of the current packet, and if it is 254\r\n\t\t// characters, flush the packet to disk.\r\n\t\tvar char_out = function char_out(c, outs) {\r\n\t\t\taccum[a_count++] = c;\r\n\t\t\tif (a_count >= 254) flush_char(outs);\r\n\t\t};\r\n\r\n\t\t// Clear out the hash table\r\n\t\t// table clear for block compress\r\n\r\n\t\tvar cl_block = function cl_block(outs) {\r\n\t\t\tcl_hash(hsize);\r\n\t\t\tfree_ent = ClearCode + 2;\r\n\t\t\tclear_flg = true;\r\n\t\t\toutput(ClearCode, outs);\r\n\t\t};\r\n\r\n\t\t// reset code table\r\n\t\tvar cl_hash = function cl_hash(hsize) {\r\n\t\t\tfor (var i = 0; i < hsize; ++i) htab[i] = -1;\r\n\t\t};\r\n\r\n\t\tvar compress = exports.compress = function compress(init_bits, outs) {\r\n\r\n\t\t\tvar fcode;\r\n\t\t\tvar i; /* = 0 */\r\n\t\t\tvar c;\r\n\t\t\tvar ent;\r\n\t\t\tvar disp;\r\n\t\t\tvar hsize_reg;\r\n\t\t\tvar hshift;\r\n\r\n\t\t\t// Set up the globals: g_init_bits - initial number of bits\r\n\t\t\tg_init_bits = init_bits;\r\n\r\n\t\t\t// Set up the necessary values\r\n\t\t\tclear_flg = false;\r\n\t\t\tn_bits = g_init_bits;\r\n\t\t\tmaxcode = MAXCODE(n_bits);\r\n\r\n\t\t\tClearCode = 1 << (init_bits - 1);\r\n\t\t\tEOFCode = ClearCode + 1;\r\n\t\t\tfree_ent = ClearCode + 2;\r\n\r\n\t\t\ta_count = 0; // clear packet\r\n\r\n\t\t\tent = nextPixel();\r\n\r\n\t\t\thshift = 0;\r\n\t\t\tfor (fcode = hsize; fcode < 65536; fcode *= 2)\r\n\t\t\t\t++hshift;\r\n\t\t\thshift = 8 - hshift; // set hash code range bound\r\n\r\n\t\t\thsize_reg = hsize;\r\n\t\t\tcl_hash(hsize_reg); // clear hash table\r\n\r\n\t\t\toutput(ClearCode, outs);\r\n\r\n\t\t\touter_loop: while ((c = nextPixel()) != EOF) {\r\n\t\t\t\tfcode = (c << maxbits) + ent;\r\n\t\t\t\ti = (c << hshift) ^ ent; // xor hashing\r\n\r\n\t\t\t\tif (htab[i] == fcode) {\r\n\t\t\t\t\tent = codetab[i];\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse if (htab[i] >= 0) { // non-empty slot\r\n\r\n\t\t\t\t\tdisp = hsize_reg - i; // secondary hash (after G. Knott)\r\n\t\t\t\t\tif (i === 0) disp = 1;\r\n\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tif ((i -= disp) < 0)\r\n\t\t\t\t\t\t\ti += hsize_reg;\r\n\r\n\t\t\t\t\t\tif (htab[i] == fcode) {\r\n\t\t\t\t\t\t\tent = codetab[i];\r\n\t\t\t\t\t\t\tcontinue outer_loop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} while (htab[i] >= 0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\toutput(ent, outs);\r\n\t\t\t\tent = c;\r\n\t\t\t\tif (free_ent < maxmaxcode) {\r\n\t\t\t\t\tcodetab[i] = free_ent++; // code -> hashtable\r\n\t\t\t\t\thtab[i] = fcode;\r\n\t\t\t\t}\r\n\t\t\t\telse cl_block(outs);\r\n\t\t\t}\r\n\r\n\t\t\t// Put out the final code.\r\n\t\t\toutput(ent, outs);\r\n\t\t\toutput(EOFCode, outs);\r\n\t\t};\r\n\r\n\t\t// ----------------------------------------------------------------------------\r\n\t\tvar encode = exports.encode = function encode(os) {\r\n\t\t\tos.writeByte(initCodeSize); // write \"initial code size\" byte\r\n\t\t\tremaining = imgW * imgH; // reset navigation variables\r\n\t\t\tcurPixel = 0;\r\n\t\t\tcompress(initCodeSize + 1, os); // compress and write the pixel data\r\n\t\t\tos.writeByte(0); // write block terminator\r\n\t\t};\r\n\r\n\t\t// Flush the packet to disk, and reset the accumulator\r\n\t\tvar flush_char = function flush_char(outs) {\r\n\t\t\tif (a_count > 0) {\r\n\t\t\t\touts.writeByte(a_count);\r\n\t\t\t\touts.writeBytes(accum, 0, a_count);\r\n\t\t\t\ta_count = 0;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar MAXCODE = function MAXCODE(n_bits) {\r\n\t\t\treturn (1 << n_bits) - 1;\r\n\t\t};\r\n\r\n\t\t// ----------------------------------------------------------------------------\r\n\t\t// Return the next pixel from the image\r\n\t\t// ----------------------------------------------------------------------------\r\n\r\n\t\tvar nextPixel = function nextPixel() {\r\n\t\t\tif (remaining === 0) return EOF;\r\n\t\t\t--remaining;\r\n\t\t\tvar pix = pixAry[curPixel++];\r\n\t\t\treturn pix & 0xff;\r\n\t\t};\r\n\r\n\t\tvar output = function output(code, outs) {\r\n\r\n\t\t\tcur_accum &= masks[cur_bits];\r\n\r\n\t\t\tif (cur_bits > 0) cur_accum |= (code << cur_bits);\r\n\t\t\telse cur_accum = code;\r\n\r\n\t\t\tcur_bits += n_bits;\r\n\r\n\t\t\twhile (cur_bits >= 8) {\r\n\t\t\t\tchar_out((cur_accum & 0xff), outs);\r\n\t\t\t\tcur_accum >>= 8;\r\n\t\t\t\tcur_bits -= 8;\r\n\t\t\t}\r\n\r\n\t\t\t// If the next entry is going to be too big for the code size,\r\n\t\t\t// then increase it, if possible.\r\n\r\n\t\t\tif (free_ent > maxcode || clear_flg) {\r\n\r\n\t\t\t\tif (clear_flg) {\r\n\r\n\t\t\t\t\tmaxcode = MAXCODE(n_bits = g_init_bits);\r\n\t\t\t\t\tclear_flg = false;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t++n_bits;\r\n\t\t\t\t\tif (n_bits == maxbits) maxcode = maxmaxcode;\r\n\t\t\t\t\telse maxcode = MAXCODE(n_bits);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (code == EOFCode) {\r\n\r\n\t\t\t\t// At EOF, write the rest of the buffer.\r\n\t\t\t\twhile (cur_bits > 0) {\r\n\t\t\t\t\tchar_out((cur_accum & 0xff), outs);\r\n\t\t\t\t\tcur_accum >>= 8;\r\n\t\t\t\t\tcur_bits -= 8;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tflush_char(outs);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tLZWEncoder.apply(this, arguments);\r\n\t\treturn exports;\r\n\t}\r\n}\r\n"],"sourceRoot":"/source/"}